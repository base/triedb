//! Structs to enable the computation of values generated by [`StorageEngine`] in background
//! threads.

use crate::{
    context::TransactionContext,
    executor::Wait,
    node::Node,
    page::{PageId, SlottedPageMut},
    storage::engine::StorageEngine,
};
use std::{
    cell::LazyCell,
    collections::HashMap,
    fmt::Debug,
    ops::{Deref, DerefMut},
};

#[derive(Default, Debug)]
pub(super) struct DeferredChanges {
    set: HashMap<(PageId, u8), Node>,
}

impl DeferredChanges {
    pub(super) fn new() -> Self {
        Self::default()
    }

    pub(super) fn set_value(&mut self, page_id: PageId, index: u8, value: Node) {
        self.set.insert((page_id, index), value);
    }

    pub(super) fn delete_value(&mut self, page_id: PageId, index: u8) {
        self.set.remove(&(page_id, index));
    }

    pub(super) fn swap_cell_pointers(&mut self, page_id: PageId, index1: u8, index2: u8) {
        let value1 = self.set.remove(&(page_id, index1));
        let value2 = self.set.remove(&(page_id, index2));
        if let Some(value1) = value1 {
            self.set.insert((page_id, index2), value1);
        }
        if let Some(value2) = value2 {
            self.set.insert((page_id, index1), value2);
        }
    }

    pub(super) fn orphan_page(&mut self, remove_page_id: PageId) {
        self.set.retain(|&(page_id, _index), _value| page_id != remove_page_id);
    }

    pub(super) fn flush(&mut self, engine: &StorageEngine, context: &mut TransactionContext) {
        for ((page_id, index), value) in self.set.drain() {
            let mut slotted_page = SlottedPageMut::try_from(
                engine.get_mut_page(context, page_id).expect("page disappeared"),
            )
            .expect("page could not be parsed");
            slotted_page.set_value(index, value.wait()).expect("set failed");
        }
    }

    pub(super) fn flush_page_id(
        &mut self,
        engine: &StorageEngine,
        context: &mut TransactionContext,
        flush_page_id: PageId,
    ) {
        // Don't retrieve the page unless it's present in our set (retrieving pages is expensive
        // due to the use of atomic operations).
        let slotted_page = LazyCell::new(|| {
            SlottedPageMut::try_from(
                engine.get_mut_page(context, flush_page_id).expect("page disappeared"),
            )
            .expect("page could not be parsed")
        });
        self.flush_page_generic(flush_page_id, slotted_page);
    }

    pub(super) fn flush_page(&mut self, slotted_page: &mut SlottedPageMut<'_>) {
        let flush_page_id = slotted_page.id();
        self.flush_page_generic(flush_page_id, slotted_page);
    }

    fn flush_page_generic<'a, P>(&mut self, flush_page_id: PageId, mut slotted_page: P)
    where
        P: Deref<Target = SlottedPageMut<'a>> + DerefMut,
    {
        for ((_page_id, index), value) in
            self.set.extract_if(|&(page_id, _index), _value| page_id == flush_page_id)
        {
            slotted_page.set_value(index, value.wait()).expect("set failed");
        }
    }
}
